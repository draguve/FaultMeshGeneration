import h5py
import numpy as np
import typer
from scipy.spatial import KDTree
from typing_extensions import Annotated

from meshgen import get_cartesian, apply_centering_points, apply_rotation_points


def main(
        meta_file: Annotated[str, typer.Argument(help="Path for the meta file generated by meshgen script")],
        lat: Annotated[str, typer.Argument(help="Latitude to convert to point on the mesh")],
        long: Annotated[str, typer.Argument(help="Longitude to convert to point on the mesh")],
        depth: Annotated[
            float, typer.Option(help="How deep should the point be from the sea level (in meters)")] = -1000.0,
        # from sea level in meters
        round_to_closest_point: Annotated[
            bool, typer.Option(help="Should the point be rounded to the nearest point on the fault line")] = True
):
    with h5py.File(meta_file, "r") as f:
        closest_point = np.array([long, lat, 0])
        if round_to_closest_point:
            all_long_lats = f["all_long_lats"][:]
            center = f["center"][:]
            rotation_matrix = f["rotation_matrix"][:]
            tree = KDTree(all_long_lats[:, np.array([1, 0])])
            _, ii = tree.query([[lat, long], ], k=[1])
            closest_point = all_long_lats[ii[0][0],]
            print(f"Rounding to lat,long on the mesh {closest_point[1]} {closest_point[0]}")

        cart = get_cartesian(lat_deg=closest_point[1], lon_deg=closest_point[0], alt=depth)
        cart = apply_rotation_points(cart, rotation_matrix)
        cart = apply_centering_points(cart, center)
        print(f"Location of the point is {cart}")


if __name__ == "__main__":
    # main("outputs/meta.h5", 37.341206616740266, -121.88075569799896, -1000)
    typer.run(main)
