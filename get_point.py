import h5py
import numpy as np
import typer
from scipy.spatial import KDTree
from typing_extensions import Annotated
from generating_ASAGI_file import writeNetcdf4SeisSol, writeNetcdf4Paraview

from meshgen import get_cartesian, apply_centering_points, apply_rotation_points


def main(
        meta_file: Annotated[str, typer.Argument(help="Path for the meta file generated by meshgen script")],
        lat: Annotated[str, typer.Option(help="Latitude to convert to point on the mesh")] = 37.341206616740266,
        long: Annotated[str, typer.Option(help="Longitude to convert to point on the mesh")] = -121.88075569799896,
        depth: Annotated[
            float, typer.Option(help="How deep should the point be from the sea level (in meters)")] = -1000.0,
        # from sea level in meters
        round_to_closest_point: Annotated[
            bool, typer.Option(help="Should the point be rounded to the nearest point on the fault line")] = True,
        point_field_resolution: Annotated[
            float, typer.Option(help="Resolution for netcdf files (in m)")] = 100,
        output_distance_from_faults: Annotated[
            str, typer.Option(help="Generate netcdf file for distance from fault points")] = None,
        output_distance_from_topo: Annotated[
            str, typer.Option(help="Generate netcdf file for distance from topography points")] = None
):
    with h5py.File(meta_file, "r") as f:
        closest_point = np.array([long, lat, 0])
        if round_to_closest_point:
            all_long_lats = f["all_long_lats"][:]
            center = f["center"][:]
            rotation_matrix = f["rotation_matrix"][:]
            tree = KDTree(all_long_lats[:, np.array([1, 0])])
            _, ii = tree.query([[lat, long], ], k=[1])
            closest_point = all_long_lats[ii[0][0],]
            print(f"Rounding to lat,long on the mesh {closest_point[1]} {closest_point[0]}")

        cart = get_cartesian(lat_deg=closest_point[1], lon_deg=closest_point[0], alt=depth)
        cart = apply_rotation_points(cart, rotation_matrix)
        cart = apply_centering_points(cart, center)

        if output_distance_from_faults is not None or output_distance_from_topo is not None:
            if f.get("bounding_box") is None:
                print("Could not find bounding box in meta file, create bounding box with mesh")
                exit()

            print("generating bounding box")
            bounding_box = f.get("bounding_box")[:]
            min_coords = np.min(bounding_box, axis=0)
            max_coords = np.max(bounding_box, axis=0)

            x = np.linspace(min_coords[0], max_coords[0], int((max_coords[0] - min_coords[0]) / point_field_resolution))
            y = np.linspace(min_coords[1], max_coords[1], int((max_coords[0] - min_coords[0]) / point_field_resolution))
            z = np.linspace(min_coords[2], max_coords[2], int((max_coords[0] - min_coords[0]) / point_field_resolution))

            xg, yg, zg = np.meshgrid(x, y, z, indexing='ij')
            if output_distance_from_faults is not None:
                print("generating fault KDTree")
                fault_tree = KDTree(f["fault_points"][:])
                distances, index = fault_tree.query(np.stack((xg.flatten(), yg.flatten(), zg.flatten())).T, k=[1])
                distances = distances.squeeze().reshape(xg.shape)
                distances = np.einsum('ijk->kji', distances)
                writeNetcdf4Paraview(output_distance_from_faults, z, y, x, ["fault_distance"], [distances])
            if output_distance_from_topo is not None:
                print("generating topography KDTree")
                topo_tree = KDTree(f["topo_points"][:])
                distances, index = topo_tree.query(np.stack((xg.flatten(), yg.flatten(), zg.flatten())).T, k=[1])
                distances = distances.squeeze().reshape(xg.shape)
                distances = np.einsum('ijk->kji', distances)
                writeNetcdf4Paraview(output_distance_from_topo, z, y, x, ["topo_distance"], [distances])

        print(f"Location of the point is {cart}")


if __name__ == "__main__":
    # main("outputs/meta.h5", 37.341206616740266, -121.88075569799896, -1000)
    typer.run(main)
